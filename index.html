<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intentionality - Triangulated Torus</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a0a, 1);
        document.body.appendChild(renderer.domElement);
        
        camera.position.z = 5;
        
        // ============================================
        // TRIANGULATION DENSITY CONTROL
        // ============================================
        // Adjust these to control mesh detail
        // Higher values = more triangles = smoother surface
        const RADIAL_SEGMENTS = 22;  // Segments around the tube
        const TUBULAR_SEGMENTS = 64; // Segments around the main ring
        // ============================================
        
        // Create trefoil knot geometry
        const trefoilKnot = new THREE.Curve();
        trefoilKnot.getPoint = function(t) {
            t = t * Math.PI * 2;
            const x = Math.sin(t) + 2 * Math.sin(2 * t);
            const y = Math.cos(t) - 2 * Math.cos(2 * t);
            const z = -Math.sin(3 * t);
            return new THREE.Vector3(x, y, z).multiplyScalar(0.8);
        };
        
        const torusGeometry = new THREE.TubeGeometry(trefoilKnot, TUBULAR_SEGMENTS, 0.3, RADIAL_SEGMENTS, true);
        
        // Store original positions for resetting
        const originalPositions = torusGeometry.attributes.position.array.slice();
        
        // Create material with wireframe
        const material = new THREE.MeshPhongMaterial({
            color: 0x00ffff,
            wireframe: true,
            emissive: 0x003333,
            shininess: 100
        });
        
        const torus = new THREE.Mesh(torusGeometry, material);
        scene.add(torus);
        
        // ============================================
        // HIGHLIGHTED SEGMENTS CONTROL
        // ============================================
        // Number of highlighted radial segments along the trefoil
        const NUM_HIGHLIGHTED_SEGMENTS = 5; // #webpages
        // ============================================
        
        // Create highlighted segment rings
        const segmentRings = [];
        
        for (let i = 0; i < NUM_HIGHLIGHTED_SEGMENTS; i++) {
            const t = i / NUM_HIGHLIGHTED_SEGMENTS;
            const position = trefoilKnot.getPoint(t);
            
            // Create a ring geometry at this position
            const ringGeometry = new THREE.TorusGeometry(0.3, 0.05, 8, 16);
            
            // Create material for this ring (will be updated to contrast with main knot)
            const ringMaterial = new THREE.MeshPhongMaterial({
                color: 0xff00ff,
                wireframe: true,
                emissive: 0xff00ff,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });
            
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            
            // Store original positions for applying deformations
            const ringOriginalPositions = ringGeometry.attributes.position.array.slice();
            
            // Position the ring
            ring.position.copy(position);
            
            // Orient the ring to be perpendicular to the curve
            const tangent = trefoilKnot.getTangent(t);
            const axis = new THREE.Vector3(0, 0, 1);
            ring.quaternion.setFromUnitVectors(axis, tangent.normalize());
            
            scene.add(ring);
            segmentRings.push({
                mesh: ring,
                geometry: ringGeometry,
                originalPositions: ringOriginalPositions,
                t: t,
                tubularIndex: Math.floor(t * TUBULAR_SEGMENTS),
                hovered: false
            });
        }
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);
        
        const pointLight2 = new THREE.PointLight(0xff00ff, 0.5, 100);
        pointLight2.position.set(-5, -5, 5);
        scene.add(pointLight2);
        
        // Mouse tracking
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let mousePosition3D = new THREE.Vector3();
        let isMouseActive = false;
        
        // Rotation controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let manualRotation = false;
        
        // Mouse down - start dragging
        document.addEventListener('mousedown', (event) => {
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        });
        
        // Mouse up - stop dragging
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        // Track mouse movement
        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            isMouseActive = true;
            
            // Handle rotation when dragging
            if (isDragging) {
                manualRotation = true;
                
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                torus.rotation.y += deltaX * 0.01;
                torus.rotation.x += deltaY * 0.01;
                
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
            
            // Project mouse position into 3D space
            raycaster.setFromCamera(mouse, camera);
            const distance = 5; // Distance from camera
            mousePosition3D = raycaster.ray.origin.clone().add(
                raycaster.ray.direction.multiplyScalar(distance)
            );
        });
        
        document.addEventListener('mouseleave', () => {
            isMouseActive = false;
        });
        
        // ============================================
        // GRAVITATIONAL ATTRACTION CONTROL
        // ============================================
        // Adjust this value to control mouse attraction strength
        // Higher values = stronger attraction (try values between 0.05 and 0.5)
        // Lower values = weaker attraction
        // Set to 0 to disable mouse attraction
        const GRAVITATIONAL_STRENGTH = 0.2;
        // ============================================
        
        // Animation variables
        let time = 0;
        const gravitationalRadius = 3;
        const returnSpeed = 0.05;
        
        // Turbulence animation settings
        const turbulenceSpeed = 1;      // Speed of turbulence animation
        const turbulenceScale = 0.5;      // Scale of turbulence patterns
        const turbulenceAmplitude = 0.1; // Intensity of turbulence (very subtle)
        
        // ============================================
        // BROWNIAN MOTION CONTROL
        // ============================================
        // Adjust this value to control random surface motion
        // Higher values = more jittery, nervous motion
        // Set to 0 to disable Brownian motion
        const BROWNIAN_INTENSITY = 0.01;
        // ============================================
        
        // Brownian motion state (random walk for each vertex)
        const brownianOffsets = new Float32Array(torusGeometry.attributes.position.count * 3);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.01;
            
            // Auto-rotate only if not manually rotated
            if (!manualRotation) {
                torus.rotation.x += 0.003;
                torus.rotation.y += 0.005;
            }
            
            // Check for segment hover (only when not dragging)
            if (!isDragging && isMouseActive) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(segmentRings.map(s => s.mesh));
                
                // Reset all segments
                segmentRings.forEach(segment => {
                    segment.hovered = false;
                    segment.mesh.material.emissiveIntensity = 0.3;
                    segment.mesh.material.opacity = 0.9;
                    segment.mesh.scale.set(1, 1, 1);
                });
                
                // Highlight hovered segment with glow
                if (intersects.length > 0) {
                    const hoveredMesh = intersects[0].object;
                    const segment = segmentRings.find(s => s.mesh === hoveredMesh);
                    if (segment) {
                        segment.hovered = true;
                        segment.mesh.material.emissiveIntensity = 2.0; // Strong glow
                        segment.mesh.material.opacity = 1.0;
                        segment.mesh.scale.set(1.3, 1.3, 1.3);
                    }
                }
            }
            
            // Get position attribute
            const positions = torusGeometry.attributes.position;
            const vertex = new THREE.Vector3();
            
            // First pass: Update main knot vertices
            for (let i = 0; i < positions.count; i++) {
                const i3 = i * 3;
                
                // Start with original vertex position
                const originalVertex = new THREE.Vector3(
                    originalPositions[i3],
                    originalPositions[i3 + 1],
                    originalPositions[i3 + 2]
                );
                
                // Apply subtle turbulence using 3D noise-like pattern
                // Create layered sine waves for organic turbulence effect
                const turbulence = 
                    Math.sin(originalVertex.x * turbulenceScale + time * turbulenceSpeed) * 
                    Math.cos(originalVertex.y * turbulenceScale + time * turbulenceSpeed * 0.7) * 
                    Math.sin(originalVertex.z * turbulenceScale + time * turbulenceSpeed * 0.5);
                
                // Apply turbulence as small radial displacement
                const displacement = originalVertex.clone().normalize().multiplyScalar(turbulence * turbulenceAmplitude);
                vertex.copy(originalVertex).add(displacement);
                
                // Apply Brownian motion (random walk)
                if (BROWNIAN_INTENSITY > 0) {
                    // Update Brownian offsets with random walk (small random steps)
                    brownianOffsets[i3] += (Math.random() - 0.5) * BROWNIAN_INTENSITY;
                    brownianOffsets[i3 + 1] += (Math.random() - 0.5) * BROWNIAN_INTENSITY;
                    brownianOffsets[i3 + 2] += (Math.random() - 0.5) * BROWNIAN_INTENSITY;
                    
                    // Apply damping to prevent offsets from growing too large
                    const damping = 0.95;
                    brownianOffsets[i3] *= damping;
                    brownianOffsets[i3 + 1] *= damping;
                    brownianOffsets[i3 + 2] *= damping;
                    
                    // Add Brownian offsets to vertex position
                    vertex.x += brownianOffsets[i3];
                    vertex.y += brownianOffsets[i3 + 1];
                    vertex.z += brownianOffsets[i3 + 2];
                }
                
                // Gravitational pull towards mouse
                if (isMouseActive) {
                    // Transform vertex to world space
                    const worldVertex = vertex.clone().applyMatrix4(torus.matrixWorld);
                    const distance = worldVertex.distanceTo(mousePosition3D);
                    
                    if (distance < gravitationalRadius) {
                        // Calculate pull strength (gentle falloff)
                        const falloff = 1 - (distance / gravitationalRadius);
                        const pullStrength = GRAVITATIONAL_STRENGTH * falloff * falloff; // Quadratic falloff for smoother effect
                        
                        // Direction towards mouse
                        const direction = new THREE.Vector3()
                            .subVectors(mousePosition3D, worldVertex)
                            .normalize();
                        
                        // Transform direction back to local space
                        const inverseMatrix = new THREE.Matrix4().copy(torus.matrixWorld).invert();
                        direction.applyMatrix4(inverseMatrix).normalize();
                        
                        // Apply gentle pull as an offset
                        vertex.add(direction.multiplyScalar(pullStrength));
                    }
                }
                
                // Update position
                positions.array[i3] = vertex.x;
                positions.array[i3 + 1] = vertex.y;
                positions.array[i3 + 2] = vertex.z;
            }
            
            // Mark positions as needing update
            positions.needsUpdate = true;
            
            // Update material color with time
            const hue = (time * 0.1) % 1;
            material.color.setHSL(hue, 1, 0.5);
            material.emissive.setHSL(hue, 1, 0.2);
            
            // Update segment rings with deformations and contrasting color
            segmentRings.forEach(segment => {
                // Calculate average position from the actual deformed knot vertices
                // Get the ring of vertices at this tubular segment
                const tubularIndex = segment.tubularIndex;
                const verticesPerSegment = RADIAL_SEGMENTS + 1;
                
                // Calculate center position from deformed vertices
                let centerX = 0, centerY = 0, centerZ = 0;
                for (let r = 0; r < RADIAL_SEGMENTS; r++) {
                    const vertexIndex = tubularIndex * verticesPerSegment + r;
                    const i3 = vertexIndex * 3;
                    
                    if (i3 < positions.count * 3) {
                        centerX += positions.array[i3];
                        centerY += positions.array[i3 + 1];
                        centerZ += positions.array[i3 + 2];
                    }
                }
                centerX /= RADIAL_SEGMENTS;
                centerY /= RADIAL_SEGMENTS;
                centerZ /= RADIAL_SEGMENTS;
                
                // Update ring position to match deformed center
                const deformedCenter = new THREE.Vector3(centerX, centerY, centerZ);
                deformedCenter.applyMatrix4(torus.matrixWorld);
                segment.mesh.position.copy(deformedCenter);
                
                // Update orientation to match the curve
                const tangent = trefoilKnot.getTangent(segment.t);
                const axis = new THREE.Vector3(0, 0, 1);
                const rotatedTangent = tangent.clone().applyQuaternion(torus.quaternion);
                segment.mesh.quaternion.setFromUnitVectors(axis, rotatedTangent.normalize());
                
                // Set contrasting color (opposite hue)
                const contrastHue = (hue + 0.5) % 1;
                segment.mesh.material.color.setHSL(contrastHue, 1, 0.5);
                segment.mesh.material.emissive.setHSL(contrastHue, 1, segment.hovered ? 0.8 : 0.2);
                
                // Apply deformations from the main knot to the ring vertices
                const ringPositions = segment.geometry.attributes.position;
                const ringVertex = new THREE.Vector3();
                
                for (let i = 0; i < ringPositions.count; i++) {
                    const i3 = i * 3;
                    
                    // Start with original ring vertex
                    const originalRingVertex = new THREE.Vector3(
                        segment.originalPositions[i3],
                        segment.originalPositions[i3 + 1],
                        segment.originalPositions[i3 + 2]
                    );
                    
                    // Sample turbulence at this position (transformed to world space)
                    const worldPos = originalRingVertex.clone()
                        .applyMatrix4(segment.mesh.matrixWorld);
                    
                    const turbulence = 
                        Math.sin(worldPos.x * turbulenceScale + time * turbulenceSpeed) * 
                        Math.cos(worldPos.y * turbulenceScale + time * turbulenceSpeed * 0.7) * 
                        Math.sin(worldPos.z * turbulenceScale + time * turbulenceSpeed * 0.5);
                    
                    const displacement = originalRingVertex.clone().normalize()
                        .multiplyScalar(turbulence * turbulenceAmplitude);
                    ringVertex.copy(originalRingVertex).add(displacement);
                    
                    // Apply Brownian motion proportional to the main knot
                    if (BROWNIAN_INTENSITY > 0) {
                        const brownianScale = 0.5; // Rings have less Brownian than main knot
                        ringVertex.x += (Math.random() - 0.5) * BROWNIAN_INTENSITY * brownianScale;
                        ringVertex.y += (Math.random() - 0.5) * BROWNIAN_INTENSITY * brownianScale;
                        ringVertex.z += (Math.random() - 0.5) * BROWNIAN_INTENSITY * brownianScale;
                    }
                    
                    // Update ring vertex position
                    ringPositions.array[i3] = ringVertex.x;
                    ringPositions.array[i3 + 1] = ringVertex.y;
                    ringPositions.array[i3 + 2] = ringVertex.z;
                }
                
                ringPositions.needsUpdate = true;
            });
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>